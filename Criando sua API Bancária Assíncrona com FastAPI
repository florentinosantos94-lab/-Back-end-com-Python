from fastapi import FastAPI, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from fastapi_jwt_auth import AuthJWT
from fastapi_jwt_auth.exceptions import AuthJWTException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Literal
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, relationship, declarative_base
from sqlalchemy import Column, Integer, String, Float, ForeignKey, DateTime, func
from passlib.context import CryptContext

# --- Configurações JWT ---
class Settings(BaseModel):
    authjwt_secret_key: str = "supersecretkey"  # Troque para uma chave segura em produção

@AuthJWT.load_config
def get_config():
    return Settings()

# --- Tratamento global de exceções JWT ---
app = FastAPI(title="API Bancária Assíncrona com FastAPI")

@app.exception_handler(AuthJWTException)
def authjwt_exception_handler(request: Request, exc: AuthJWTException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.message}
    )

# --- Configuração do banco de dados Async ---
DATABASE_URL = "postgresql+asyncpg://user:password@localhost:5432/bancodb"  # Ajuste conforme seu ambiente

engine = create_async_engine(DATABASE_URL, echo=True)
AsyncSessionLocal = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
Base = declarative_base()

# --- Contexto para hash de senhas ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- Modelos SQLAlchemy ---
class Conta(Base):
    __tablename__ = "contas"
    id = Column(Integer, primary_key=True, index=True)
    usuario = Column(String, unique=True, index=True)
    senha_hash = Column(String)
    saldo = Column(Float, default=0.0)
    transacoes = relationship("Transacao", back_populates="conta")

class Transacao(Base):
    __tablename__ = "transacoes"
    id = Column(Integer, primary_key=True, index=True)
    conta_id = Column(Integer, ForeignKey("contas.id"))
    tipo = Column(String)  # "deposito" ou "saque"
    valor = Column(Float)
    data = Column(DateTime(timezone=True), server_default=func.now())
    conta = relationship("Conta", back_populates="transacoes")

# --- Schemas Pydantic ---
class ContaCreate(BaseModel):
    usuario: str
    senha: str

class ContaResponse(BaseModel):
    id: int
    usuario: str
    saldo: float

    class Config:
        orm_mode = True

class TransacaoCreate(BaseModel):
    tipo: Literal["deposito", "saque"]
    valor: float

class TransacaoResponse(BaseModel):
    id: int
    tipo: str
    valor: float
    data: str

    class Config:
        orm_mode = True

# --- Funções utilitárias ---
def hash_senha(senha: str) -> str:
    return pwd_context.hash(senha)

def verificar_senha(senha: str, senha_hash: str) -> bool:
    return pwd_context.verify(senha, senha_hash)

# --- Dependency para sessão async ---
async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

# --- Endpoints ---

# Criar conta
@app.post("/contas/", response_model=ContaResponse, status_code=status.HTTP_201_CREATED)
async def criar_conta(conta: ContaCreate, db: AsyncSession = Depends(get_db)):
    # Verifica se usuário já existe
    result = await db.execute(
        "SELECT id FROM contas WHERE usuario = :usuario", {"usuario": conta.usuario}
    )
    if result.first():
        raise HTTPException(status_code=400, detail="Usuário já cadastrado")

    nova_conta = Conta(usuario=conta.usuario, senha_hash=hash_senha(conta.senha))
    db.add(nova_conta)
    await db.commit()
    await db.refresh(nova_conta)
    return nova_conta

# Login para obter token JWT
@app.post("/login/")
async def login(form_data: OAuth2PasswordRequestForm = Depends(), Authorize: AuthJWT = Depends(), db: AsyncSession = Depends(get_db)):
    result = await db.execute(
        "SELECT * FROM contas WHERE usuario = :usuario", {"usuario": form_data.username}
    )
    conta_row = result.first()
    if not conta_row:
        raise HTTPException(status_code=401, detail="Usuário ou senha inválidos")

    conta = await db.get(Conta, conta_row.id)
    if not verificar_senha(form_data.password, conta.senha_hash):
        raise HTTPException(status_code=401, detail="Usuário ou senha inválidos")

    access_token = Authorize.create_access_token(subject=conta.usuario)
    return {"access_token": access_token, "token_type": "bearer"}

# Criar transação (depósito ou saque)
@app.post("/transacoes/", response_model=TransacaoResponse)
async def criar_transacao(
    transacao: TransacaoCreate,
    Authorize: AuthJWT = Depends(),
    db: AsyncSession = Depends(get_db)
):
    Authorize.jwt_required()
    usuario = Authorize.get_jwt_subject()

    # Busca conta do usuário
    result = await db.execute(
        "SELECT * FROM contas WHERE usuario = :usuario", {"usuario": usuario}
    )
    conta_row = result.first()
    if not conta_row:
        raise HTTPException(status_code=404, detail="Conta não encontrada")

    conta = await db.get(Conta, conta_row.id)

    if transacao.valor <= 0:
        raise HTTPException(status_code=400, detail="Valor deve ser positivo")

    if transacao.tipo == "saque" and transacao.valor > conta.saldo:
        raise HTTPException(status_code=400, detail="Saldo insuficiente")

    # Atualiza saldo
    if transacao.tipo == "deposito":
        conta.saldo += transacao.valor
    else:
        conta.saldo -= transacao.valor

    nova_transacao = Transacao(
        conta_id=conta.id,
        tipo=transacao.tipo,
        valor=transacao.valor
    )
    db.add(nova_transacao)
    db.add(conta)  # Atualiza saldo
    await db.commit()
    await db.refresh(nova_transacao)
    return nova_transacao

# Extrato da conta
@app.get("/extrato/", response_model=List[TransacaoResponse])
async def extrato(Authorize: AuthJWT = Depends(), db: AsyncSession = Depends(get_db)):
    Authorize.jwt_required()
    usuario = Authorize.get_jwt_subject()

    result = await db.execute(
        "SELECT * FROM contas WHERE usuario = :usuario", {"usuario": usuario}
    )
    conta_row = result.first()
    if not conta_row:
        raise HTTPException(status_code=404, detail="Conta não encontrada")

    transacoes = await db.execute(
        "SELECT * FROM transacoes WHERE conta_id = :conta_id ORDER BY data DESC", {"conta_id": conta_row.id}
    )
    transacoes_list = transacoes.fetchall()

    return [
        TransacaoResponse(
            id=t.id,
            tipo=t.tipo,
            valor=t.valor,
            data=t.data.isoformat()
        )
        for t in transacoes_list
    ]

# Criação das tabelas no startup
@app.on_event("startup")
async def startup():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)



Como usar:
Ajuste a variável DATABASE_URL para seu banco PostgreSQL.
Instale as dependências:
bash

pip install fastapi uvicorn sqlalchemy[asyncio] asyncpg passlib[bcrypt] python-jose fastapi-jwt-auth
Rode a API:
bash

uvicorn main:app --reload
Use /contas/ para criar usuário, /login/ para obter token JWT.
Use o token para acessar /transacoes/ e /extrato/.
Documentação interativa em http://127.0.0.1:8000/docs.
